"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.VulcanHebeCe = exports.VulcanJwtRegister = exports.Keystore = exports.Keypair = void 0;
const generateKeyPair_1 = __importDefault(require("./lib/generateKeyPair"));
const registerJwt_1 = __importDefault(require("./functions/registerJwt"));
const registerHebe_1 = __importDefault(require("./functions/registerHebe"));
const luckyNumber_1 = __importDefault(require("./functions/luckyNumber"));
const parseApiAp_1 = __importDefault(require("./utilities/parseApiAp"));
const grades_1 = __importDefault(require("./functions/grades"));
const homeWork_1 = __importDefault(require("./functions/homeWork"));
const temporaryDb_1 = __importDefault(require("./utilities/temporaryDb"));
exports.Keystore = temporaryDb_1.default;
const lessons_1 = __importDefault(require("./functions/lessons"));
const changedLessons_1 = __importDefault(require("./functions/changedLessons"));
const attendance_1 = __importDefault(require("./functions/attendance"));
const exams_1 = __importDefault(require("./functions/exams"));
const messagesGet_1 = __importDefault(require("./functions/messagesGet"));
const addressbook_1 = __importDefault(require("./functions/addressbook"));
class Keypair {
    /**
     * Creates a new Keypair manager for authentication with VULCAN HebeCE API.
     *
     * @async
     * @returns
     */
    constructor() { }
    /**
     * Generates a new keypair and returns it.
     *
     * @returns
     */
    async init() {
        // @ts-ignore
        const keypair = await new generateKeyPair_1.default();
        return {
            fingerprint: keypair.fingerprint,
            privateKey: keypair.privateKey,
            certificate: keypair.certificate
        };
    }
}
exports.Keypair = Keypair;
;
class VulcanJwtRegister {
    keypair;
    apiap;
    tokenIndex;
    /**
     * Creates a manager for authentication with VULCAN HebeCE API.
     *
     * @param keypair The Keypair to authenticate
     * @param apiap The /api/ap content
     * @param tokenIndex What token should be authenticated? (Multistudent)
     * @returns {JwtOutput}
     */
    constructor(keypair, apiap, tokenIndex) {
        this.keypair = keypair;
        this.apiap = apiap;
        this.tokenIndex = tokenIndex;
    }
    ;
    /**
     * Registers your Keypair with a JWT to send requests to VULCAN HebeCE API.
     *
     * @async
     */
    async init() {
        const keypair = this.keypair;
        const apiap = this.apiap;
        const tokenIndex = this.tokenIndex;
        const parsedAp = await (0, parseApiAp_1.default)(apiap);
        const token = parsedAp.Tokens[tokenIndex];
        const jwt = await (0, registerJwt_1.default)(token, keypair);
        return jwt;
    }
}
exports.VulcanJwtRegister = VulcanJwtRegister;
class VulcanHebeCe {
    keypair;
    restUrl;
    symbolNumber;
    pupilId;
    pupilJson;
    constituentId;
    /**
     * Creates the main manager for VULCAN HebeCE API functionality.
     * @param keypair The Keypair to authenticate
     * @param restUrl The REST URL that the API should use
     * @returns
     */
    constructor(keypair, restUrl) {
        this.keypair = keypair;
        this.restUrl = restUrl;
    }
    /**
     * Connects to the VULCAN HebeCE API.
     */
    async connect() {
        const pupilData = await (0, registerHebe_1.default)(this.keypair, this.restUrl);
        const symbolNumber = pupilData.Envelope[0].Links.Symbol;
        const pupilId = pupilData.Envelope[0].Pupil.Id;
        const constituentId = pupilData.Envelope[0].ConstituentUnit.Id;
        this.symbolNumber = symbolNumber;
        this.pupilId = pupilId;
        this.pupilJson = pupilData;
        this.constituentId = constituentId;
        return true;
    }
    /**
     * Gets lucky number from the API.
     * @async
     * @returns {LuckyNumber}
     */
    async getLuckyNumber() {
        if (!this.symbolNumber || !this.pupilId || !this.constituentId)
            throw new Error(`You are not connected! Maybe .connect()?`);
        const lucky = await (0, luckyNumber_1.default)(this.keypair, this.restUrl, this.pupilJson);
        return lucky;
    }
    /**
     * Gets your homework from the API.
     * @param dateFrom The start of the date range
     * @param dateTo  The end of the date range
     * @async
     * @returns {Homework}
     */
    async getHomework(dateFrom, dateTo) {
        if (!this.symbolNumber || !this.pupilId || !this.constituentId)
            throw new Error(`You are not connected! Maybe .connect()?`);
        const homework = await (0, homeWork_1.default)(this.keypair, this.restUrl, this.pupilJson, dateFrom, dateTo);
        return homework;
    }
    /**
     * Gets your grades for the current period from the API.
     * @async
     * @returns {Grade}
     */
    async getGrades() {
        if (!this.symbolNumber || !this.pupilId || !this.constituentId)
            throw new Error(`You are not connected! Maybe .connect()?`);
        const grades = await (0, grades_1.default)(this.keypair, this.restUrl, this.pupilJson);
        return grades;
    }
    /**
     * Gets your timetable from the API.
     * @param dateFrom The start of the date range
     * @param dateTo The end of the date range
     * @async
     * @returns {Lesson}
     */
    async getLessons(dateFrom, dateTo) {
        if (!this.symbolNumber || !this.pupilId || !this.constituentId)
            throw new Error(`You are not connected! Maybe .connect()?`);
        const lessons = await (0, lessons_1.default)(this.keypair, this.restUrl, this.pupilJson, dateFrom, dateTo);
        return lessons;
    }
    /**
     * Gets your substitutions from the API.
     * @param dateFrom The start of the date range
     * @param dateTo The end of the date range
     * @async
     * @returns {ChangedLesson}
     */
    async getChangedLessons(dateFrom, dateTo) {
        if (!this.symbolNumber || !this.pupilId || !this.constituentId)
            throw new Error(`You are not connected! Maybe .connect()?`);
        const lessons = await (0, changedLessons_1.default)(this.keypair, this.restUrl, this.pupilJson, dateFrom, dateTo);
        return lessons;
    }
    /**
     * Gets your attendance from the API.
     * @param dateFrom The start of the date range
     * @param dateTo The end of the date range
     * @returns {Attendance}
     */
    async getAttendance(dateFrom, dateTo) {
        if (!this.symbolNumber || !this.pupilId || !this.constituentId)
            throw new Error(`You are not connected! Maybe .connect()?`);
        const attendanceobj = await (0, attendance_1.default)(this.keypair, this.restUrl, this.pupilJson, dateFrom, dateTo);
        return attendanceobj;
    }
    /**
     * Gets your exams from the API.
     * @param dateFrom The start of the date range
     * @param dateTo The end of the date range
     * @returns {Exam}
     */
    async getExams(dateFrom, dateTo) {
        if (!this.symbolNumber || !this.pupilId || !this.constituentId)
            throw new Error(`You are not connected! Maybe .connect()?`);
        const examsobj = await (0, exams_1.default)(this.keypair, this.restUrl, this.pupilJson, dateFrom, dateTo);
        return examsobj;
    }
    messages = {
        /**
         * Gets your messages from the API.
         *
         * Messages are automatically sorted from newest to oldest.
         * @param type The type of the message (0 = received, 1 = sent, 2 = deleted)
         * @param amount How many messages do you want to fetch
         * @returns {Message}
         */
        get: async (type, amount) => {
            if (!this.symbolNumber || !this.pupilId || !this.constituentId)
                throw new Error(`You are not connected! Maybe .connect()?`);
            const messages = await (0, messagesGet_1.default)(this.keypair, this.restUrl, this.pupilJson, type, amount);
            return messages;
        },
        /**
         * Gets the address book from the API.
         *
         * Useful to send a message. Contains MessageBoxes IDs that you can send a message to.
         * @returns {AddressBook}
         */
        getAddressBook: async () => {
            if (!this.symbolNumber || !this.pupilId || !this.constituentId)
                throw new Error(`You are not connected! Maybe .connect()?`);
            const addrbook = await (0, addressbook_1.default)(this.keypair, this.restUrl, this.pupilJson);
            return addrbook;
        }
    };
}
exports.VulcanHebeCe = VulcanHebeCe;
